<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NumPy, Pandas & Matplotlib | Note</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="container">
        <div class="heading">
            <h1>NumPy, Pandas & Matplotlib</h1>
        </div>

        <div class="content">
            <div class="numpy">
                <div class="intro">
                    <h2 id="top">NumPy</h2>
                    <p>It is the entry point from Python for DS. It is Numerical Python Library.</p>

                    <ul>
                        <li><span>How to Install: </span>
                            <code>>>> pip install numpy</code>
                        </li>
                        <li><span>Check Version: </span>
                            <code>>>> import numpy as np</code>
                            <br><code>>>> np.__version__</code>
                        </li>
                    </ul>

                    <h3>What is the Need of NumPy?</h3>
                    <ul>
                        <li>To perform complex mathematical operations in Data Science, ML, DL, and AI.</li>
                        <li>NumPy defines several functions to perform complex mathematical operations.</li>
                        <li>Performance is faster than python. Because most of the NumPy is implemented in C - Language.
                        </li>
                        <p><b>Q: </b>Print 10 x 10 zero matrix? (It returns float value numbers)</p>
                        <span>Ans: </span>
                        <code>>>> a = np.zeros((10, 10))
                    <br>>>> a</code>

                        <p><b>Q: </b>Print 1 to 100 in a list?</p>
                        <span>Ans: </span>
                        <code>>>> a = np.arange(1, 101)
                    <br>>>> a</code>

                        <p><b>Q: </b>Reshape "a" into 10 x 10 matrix? (Into 2-dimention array)</p>
                        <span>Ans: </span>
                        <code>>>> a.reshape(10, 10)</code>

                        <p><b>Q: </b>Print a identity matrix?</p>
                        <span>Ans: </span>
                        <code>>>> a = np.identity(3)
                    <br>>>> a</code>

                        <li><b>ndarray(): </b>N - dimentional array or numpy array. Used to store large data in nd array
                            for
                            matplot graph style purpose.</li>

                        <p><b>Q: </b>Convert values into integer, If you want only integer numbers?</p>
                        <span>Ans: </span>
                        <code>>>> a = np.zeros((10, 10), dtype = int)
                    <br>>>> a</code>

                        <li>Used for Data Analysis.</li>
                    </ul>

                    <h3>History</h3>
                    <ul>
                        <li>Origin of NumPy is "Numeric Library" Developed by Jim Hugunin in 1995.</li>
                        <li>Travis Oliphant merged the best features of Numeric and Numarray to create NumPy in 2005.
                        </li>
                        <li>It is an Open Source Library and FreeWare(available for free).</li>

                        <p><b>Q: </b>In which language NumPy was written?</p>
                        <span>Ans: </span>
                        <code>C and Python Language.</code>

                        <p><b>Q: </b>What is "ndarray" in NumPy?</p>
                        <span>Ans: </span>
                        <code>The fundamental data type to store our data. It is a one class.</code>
                        <br><code>>>> a = np.identity(3)
                    <br>>>> a
                    <br>array([[1., 0., 0.],
                               [0., 1., 0.],
                               [0., 0., 1.]])
                    <br>>>> type(a)
                    <br>&lt;class 'numpy.ndarray'&gt;</code>

                        <li>Arrays are objects of "ndarray" class present in NumPy module.</li>
                        <li><b>Array: </b>An indexed collection of homogenious elements.</li>
                        <ul>
                            <li><b>1-D Array: </b>Vector</li>
                            <li><b>2-D Array: </b>Matrix</li>
                            <li><b>n-D Array: </b>No name</li>
                        </ul>
                    </ul>

                    <h3>Array Creation</h3>
                    <span>Example: </span>
                    <code>>>> a = np.ones((3, 3), dtype = int)
                <br>>>> a
                <br>array([[1, 1, 1],
                           [1, 1, 1],
                           [1, 1, 1]])
                <br>>>> np.ones((10))
                <br>array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])</code>
                    <p>Arrays can be created by 2 ways</p>
                    <ul>
                        <li>By using array module <span>(Not recommended).</span></li>
                        <span>Example: </span>
                        <code>>>> import array
                        <br>>>> a = array.array('i', [10, 20, 30]) #i represents type:int array
                        <br>>>> print(a, type(a))
                        <br>array('i', [10, 20, 30]) &lt;class 'array.array'&gt;
                    </code>
                        <br>
                        <span>Note: </span>
                        <code>Array module is not recommended because much library support is not available.</code>
                        <li>By using NumPy Module.</li>
                        <span>Example: </span>
                        <code>import numpy as np
                        <br>>>> a = np.array([10, 20, 30])
                        <br>>>> print(type(a))
                        &lt;class 'numpy.ndarray'&gt;
                        <br>>>> print(a)
                        <br>[10 20 30]
                    </code>
                    </ul>

                    <h3>Attributes</h3>
                    <p><b>Q: </b>How to access elements of array?</p>
                    <ul>
                        <li>Basic indexing.</li>
                        <li>Slice Operations.</li>
                        <li>Advanced indexing.</li>
                        <li>Condition based selection.</li>
                    </ul>

                    <p><b>Q: </b>Find the numbers which is divisible by 6 from an array?(It is an codition based array)
                    </p>
                    <span>Ans: </span>
                    <code>>>> a = np.arange(1, 21)
                <br>>>> a
                <br>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])
                <br>>>> a[a % 6 == 0]
                <br>array([ 6, 12, 18])</code>

                    <p><b>Q: </b>How to iterate elements of an array?</p>
                    <ul><span>Ans: </span>
                        <li>Python's normal loop.</li>
                        <li>nditer()</li>
                        <li>ndenumerate()</li>
                    </ul>

                    <p><b>Q: </b>In a classroom for boys fees is $3 and for girls fees is $8, For a certain batch 2200
                        people
                        attended and $10100 fee collected. How many boys and girls attended for that batch?</p>
                    <span>Hints: </span>
                    <code>x = No. of boys
                <br>y = No. of girls
                <br>x + y = 2200
                <br>3x + 8y = 10100
                </code>
                    <br>
                    <span>Ans: </span>
                    <code>
                    Coefficient Matrix:
                    <br>a = 1 1
                    <br>3 8
                    <br>>>> a = np.array([[1, 1], [3, 8]])
                    <br>>>> a
                    <br>array([[1, 1],
                           [3, 8]])
                    <br>>>> b = np.array([2200, 10100])
                    <br>>>> b
                    <br>array([ 2200, 10100])
                    <br>>>> c = np.linalg.solve(a, b)
                    <br>>>> c
                    <br>array([1500.,  700.])
                </code>

                    <h3>Python's List Vs NumPy ndarray</h3>
                    <p>
                        <b>Similarityies:</b>
                    <ul>
                        <li>Both are used to store data.</li>
                        <li>The order will be preserved in both. Hence indexing and slicing concepts are applicable.
                        </li>
                        <li>Both are mutable, i.e we can change the content.</li>
                    </ul>
                    </p>

                    <p>
                        <b>Differences:</b>
                    <ul>
                        <li>List is Python's inbuilt type. But We have to install and import <span>"numpy"</span>
                            explicitly.
                        </li>
                        <li>List can contain heterogeneous elements. But array contains only homogeneous elements.</li>
                        <span>Example: </span>
                        <code>
                            import numpy as np
                            <br>>>> l = [10, 20.5, 'Tony', True]
                            <br>>>> print(l)
                            <br>[10, 20.5, 'Tony', True]
                            <br>>>> a = np.array(l)
                            <br>>>> print(a)
                            <br>['10' '20.5' 'Tony' 'True']
                        </code>
                        <li>On list we cann't perform vector operations.But on ndarray we can perform vector opeartions.
                        </li>
                        <span>Example: </span>
                        <code>
                            import numpy as np
                            <br>>>> l = [10, 20, 30]
                            <br>>>> a = np.array(l)
                            <br>>>> l + 2 #Invalid
                            <br>>>> a + 2 #array([12, 22, 32])
                            <br>>>> l / 2 #Invalid
                            <br>>>> a / 2 #array([ 5., 10., 15.])
                            <br>>>> l * 2 #[10, 20, 30, 10, 20, 30]
                            <br>>>> a * 2 #array([20, 40, 60])
                        </code>
                        <li>Arrays consume less memory than the List.</li>
                        <li>Arrays are superfast when compared with List.</li>
                        <li>NumPy arrays are more convenient to use while performing complex mathematical operations.
                        </li>
                    </ul>
                    </p>

                    <h3>How to create NumPy Arrays</h3>
                    <ul>
                        <li>array()</li>
                        <li>arange()</li>
                        <li>linespace()</li>
                        <li>zeros()</li>
                        <li>ones()</li>
                        <li>full()</li>
                        <li>eye()</li>
                        <li>identity()</li>
                        <li>empty()</li>
                        <li>numpy.random</li>
                        <ul>
                            <li>randint()</li>
                            <li>rand()</li>
                            <li>uniform()</li>
                            <li>randn()</li>
                            <li>normal()</li>
                            <li>shuffle()</li>
                        </ul>
                    </ul>
                </div>

                <div class="arrayCreation">
                    <h3>Creation of NumPy arrays by using array():</h3>
                    <p>For the given list or tuple.</p>
                    <code>
                    >>> import numpy as np
                    <br>>>> help(np.array)
                </code>

                    <p>
                        <b>1-D Array:</b>
                        <code>
                        >>> l = [10, 20, 30]
                        <br>>>> type(l)
                        <br>&lt;class 'list'&gt;
                        <br>>>> a = np.array(l)
                        <br>>>> a #array([10, 20, 30])
                        <br>>>> a.ndim #1
                        <br>>>> type(a) #&lt;class 'numpy.ndarray'&gt;
                        <br>>>> a.dtype #dtype('int64')
                    </code>
                    </p>
                    <p>
                        <span>Note: </span>
                    <ul>
                        <li>a.ndim -- To know the dimention of ndarray.</li>
                        <li>a.dtype -- To know the data type of elements.</li>
                    </ul>
                    </p>

                    <p>
                        <b>2-d Array:</b>
                        [[10, 20, 30], [40, 50, 60], [70, 80, 90]] -- Nested list <br>
                        <span>Example: </span>
                        <code>
                        >>> a = np.array([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
                        <br>>>> a
                        <br>array([[10, 20, 30],
                        <br>[40, 50, 60],
                        <br>[70, 80, 90]])
                        <br>>>> a.ndim #2
                        <br>>>> type(a) #&lt;class 'numpy.ndarray'&gt
                        <br>>>> a.shape #(3, 3)
                        <br>>>> a.size #9
                    </code>
                    </p>

                    <h3>To create 1-D Array from the Tuple</h3>
                    <code>>>> a = np.array(('Tony', 'Peter', 'Steve'))
                    <br>>>> type(a) #&lt;class 'numpy.ndarray'&gt;
                    <br>>>> a.ndim #1
                    <br>>>> a.shape #(3,)
                    <br>>>> a #array(['Tony', 'Peter', 'Steve'], dtype='&lt;U5')
                </code>
                    <br>
                    <span>Note: </span>
                    <code>
                    Array contains only homogeneous elements.
                    <br>If the list contains heterogeneous elements: Upcasting will be performend. Int to Float.
                </code><br>
                    <span>Example: </span>
                    <code>>>> a = np.array([10, 20, 10.5])
                    <br>>>> a #array([10. , 20. , 10.5]) Upcasting int to float
                    
                    <br>>>> a = np.array([10, 20, 'a'])
                    <br>>>> a #array(['10', '20', 'a'], dtype='&lt;U21')
                </code>

                    <h3>How to create a particular Type</h3>
                    <p>We have to use dtype parameter</p>
                    <span>Example: </span>
                    <code>
                    >>> a = np.array([10, 20, 30.5], dtype = int)
                    <br>>>> a #array([10, 20, 30])
                    <br>>>> a = np.array([10, 20, 30.5], dtype = bool)
                    <br>>>> a #array([ True,  True,  True])
                    <br>>>> a = np.array([10, 20, 30.5], dtype = str)
                    <br>>>> a #array(['10', '20', '30.5'], dtype='&lt;U4')
                    <br>>>> a = np.array([10, 20, 30.5], dtype = float)
                    <br>>>> a #array([10. , 20. , 30.5])
                    <br>>>> a = np.array([10, 20, 30.5], dtype = complex)
                    <br>>>> a #array([10. +0.j, 20. +0.j, 30.5+0.j])
                    <br>>>> a = np.array([10, "Tony"], dtype=int) #Invalid
                </code>

                    <h3>How to create Object type Array</h3>
                    <span>Example: </span>
                    <code>
                    >>> a = np.array([10, 'Tony', True, 10.5, 10+3j], dtype=object)
                    <br>>>> a #array([10, 'Tony', True, 10.5, (10+3j)], dtype=object)
                    <br>
                    <br>>>> a = np.array([10, 'Tony', True, 10.5, 10+3j])
                    <br>>>> a #array(['10', 'Tony', 'True', '10.5', '(10+3j)'], dtype='&lt;U64')
                </code>

                    <h3>Creation of ndarray by using arange() function</h3>
                    <span>Syntax: </span>
                    <code> arange([start,] stop[, step,], dtype=None, *, device=None, like=None)</code>
                    <p><b>Q: </b>Create 1-D array 0 to 9?</p>
                    <span>Ans: </span>
                    <code>>>> a = np.arange(10)
                    <br>>>> a #array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
                    <br>>>> a.ndim #1
                    <br>>>> a.shape #(10,)
                    <br>>>> a.dtype #dtype('int64')
                    <br>>>> a = np.arange(1, 11, 2)
                    <br>>>> a #array([1, 3, 5, 7, 9])
                    <br>>>> a = np.arange(1, 11, 2, dtype = float)
                    <br>>>> a #array([1., 3., 5., 7., 9.])
                </code>

                    <h3>linspace()</h3>
                    <ul>
                        <li>In the specified interval, linearly spaced values.</li>
                        <span>Syntax: </span>
                        <code>linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0, *, device=None)</code>
                        <li>Return evenly spaced numbers over a specified interval.</li>
                        <span>Example: </span>
                        <code>>>> np.linspace(0, 1, 2) #array([0., 1.])
                        <br>>>> np.linspace(0, 1, 3) #array([0. , 0.5, 1. ])
                        <br>>>> np.linspace(0, 1, 4) #array([0.        , 0.33333333, 0.66666667, 1.        ])
                        <br>>>> np.linspace(0, 1)
                        <br>>>> np.linspace(0, 1).size #50
                        <br>>>> np.linspace(0, 1).shape #(50,)
                        <br>>>> np.linspace(1, 100, 10, dtype = int) #array([  1,  12,  23,  34,  45,  56,  67,  78,  89, 100])
                        <br>
                        <br>(1 - 12 = 11 numbers
                        <br>12 - 23 = 11 numbers
                        <br>equally spaced values)
                    </code>
                    </ul>

                    <h3>arange() vs linspace()</h3>
                    <ul>
                        <li><b>arange(): </b>Elements will be considered in the given range based on step value.</li>
                        <li><b>linspace(): </b>The specified number of values will be considered in the given range.
                        </li>
                    </ul>

                    <h3>zeros()</h3>
                    <ul>
                        <li>(10, ) - 1-D array contains 10 elements.</li>
                        <li>(5, 2) - 2-D array contains 5 rows and 2 columns. It means collectionof 1-D arrays.</li>
                        <li>(2, 3,4) - 3-D array collection of two 2-D arrays.</li>
                        <span>Syntax: </span>
                        <code>zeros(shape, dtype=float, order='C', *, like=None)</code>
                        <li>
                            <span>Example: </span>
                            <code>>>> np.zeros(4) #array([0., 0., 0., 0.])
                            <br>>>> np.zeros((4, 3)) #array([[0., 0., 0.],
                                   [0., 0., 0.],
                                   [0., 0., 0.],
                                   [0., 0., 0.]])
                            <br>>>> np.zeros((2, 3, 4))
                            #array([[[0., 0., 0., 0.],
                                    [0., 0., 0., 0.],
                                    [0., 0., 0., 0.]],
                            
                                   [[0., 0., 0., 0.],
                                    [0., 0., 0., 0.],
                                    [0., 0., 0., 0.]]])
                                </code>
                        </li>

                        <li>It is used when perform some operations the result we have to store somewhere.</li>
                    </ul>

                    <h3>ones()</h3>
                    <ul>
                        <li>Exactly same as zeros() except that instead of zero array filled with 1. <br>fill_value: 1
                        </li>
                        <span>Syntax: </span>
                        <code>ones(shape, dtype = None, order = 'C', *, like = None)</code>
                        <li>Return a new array of given shape and type, filled with ones.</li>
                        <span>Example: </span>
                        <code>>>> np.ones(10)
                        #array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])
                        <br>>>> np.ones((4, 2))
                        #array([[1., 1.],
                               [1., 1.],
                               [1., 1.],
                               [1., 1.]])
                        <br>>>> np.ones((2, 3, 4), dtype = int)
                        #array([[[1, 1, 1, 1],
                                [1, 1, 1, 1],
                                [1, 1, 1, 1]],
                        
                               [[1, 1, 1, 1],
                                [1, 1, 1, 1],
                                [1, 1, 1, 1]]])
                            </code>
                    </ul>

                    <h3>full()</h3>
                    <ul>
                        <li>It is used to create a array.</li>
                        <span>Syntax: </span>
                        <code>full(shape, fill_value, dtype = None, order = 'C', *, like = None)</code>
                        <li>Returb a new array of given shape and type, filled with 'fill_value'</li>
                        <span>Example: </span>
                        <code>
                        >>> np.full(10)
                        #TypeError: full() missing 1 required positional argument: 'fill_value'
                        <br>>>> np.full(10, 2) #array([2, 2, 2, 2, 2, 2, 2, 2, 2, 2])
                        <br>>>> np.full(10, 3) #array([3, 3, 3, 3, 3, 3, 3, 3, 3, 3])
                        <br>>>> np.full((5, 4), 3)
                        #array([[3, 3, 3, 3],
                                [3, 3, 3, 3],
                                [3, 3, 3, 3],
                                [3, 3, 3, 3],
                                [3, 3, 3, 3]])
                        <br>>>> np.full((2, 3, 4), 9)
                        #array([[[9, 9, 9, 9],
                                [9, 9, 9, 9],
                                [9, 9, 9, 9]],
    
                                [[9, 9, 9, 9],
                                [9, 9, 9, 9],
                                [9, 9, 9, 9]]])
                        <br><span>Note: </span>>>> np.full(shape=(3, 4), fill_value = 6)
                        #array([[6, 6, 6, 6],
                            [6, 6, 6, 6],
                            [6, 6, 6, 6]])
                        <br>>>> np.full((3, 4), fill_value=6)
                        #array([[6, 6, 6, 6],
                            [6, 6, 6, 6],
                            [6, 6, 6, 6]])
                        <br>>>> np.full(shape=(3, 4), 6)
                        #SyntaxError: positional argument follows keyword argument
                    </code>
                    </ul>

                    <h3>eye()</h3>
                    <ul>
                        <li>It create any dimention identity matrix.</li>
                        <span>Syntax: </span>
                        <code>
                        eye(N, M=None, k=0, dtype=&lt;class 'float'&gt;, order='C', *, device=None, like=None)
                        <br>
                        <br>N - Number of rows
                        <br>M - Number of Columns
                        <br>K - Meant for diagonal
                    </code>
                        <li>Return a 2-D array with ones on the diagonal and zeros elsewhere.</li>
                        <span>Example: </span>
                        <code>>>> np.eye(2, 3)
                        #array([[1., 0., 0.],
                               [0., 1., 0.]])
                        <br>>>> np.eye(3, dtype = int)
                        #array([[1, 0, 0],
                               [0, 1, 0],
                               [0, 0, 1]])
                        <br>>>> np.eye(3, k = 1 , dtype = int)
                        #array([[0, 1, 0],
                                [0, 0, 1],
                                [0, 0, 0]])
                    </code>
                    </ul>

                    <h3>identity()</h3>
                    <ul>
                        <li>It is exactly same as "eye()" function except that, it is always square matrix(the number of
                            rows
                            and number of columns always same).</li>
                        <li>Only main diagonal contains 1's.</li>
                        <li>identity() function is a special case of eye() function.</li>
                        <span>Syntax: </span>
                        <code>identity(n, dtype=None, *, like=None)</code>
                        <li> Return the identity array. The identity array is a square array with ones on the main
                            diagonal.
                        </li>
                        <span>Example: </span>
                        <code>>>> np.identity(3)
                        #array([[1., 0., 0.],
                               [0., 1., 0.],
                               [0., 0., 1.]])
                        <br>>>> np.identity(3, dtype = int)
                        #array([[1, 0, 0],
                               [0, 1, 0],
                               [0, 0, 1]])</code>
                    </ul>

                    <h3>empty()</h3>
                    <ul>
                        <li>One empty array will be created. Garbege value printed.</li>
                        <span>Syntax: </span>
                        <code> empty(shape, dtype=float, order='C', *, device=None, like=None)</code>
                        <li>Return a new array of given shape and type, without initializing entries.</li>
                        <span>Example: </span>
                        <code>
                        >>> np.empty(3)
                        #array([1., 1., 1.])
                        <br>>>> np.empty((3, 3))
                        #array([[5.e-324, 0.e+000, 0.e+000],
                        [0.e+000, 5.e-324, 0.e+000],
                        [0.e+000, 0.e+000, 5.e-324]])
                    </code>
                    </ul>

                    <h3>zeros() vs empty()</h3>
                    <ul>
                        <li>If we required an array only with zeros then we should go for <span>zeros()</span>.</li>
                        <li>If we never worry about data, just we required an empty array for future purpose, then we
                            should
                            go for <span>empty()</span>.</li>
                        <li>The time required to create empty array is very very less when compared with zeros array.
                            <span>i.e </span>performance wise empty function is recommended than zeros if we are not
                            worry
                            about data.
                        </li>
                        <p><b>Performance comparision of zeros() and empty()</b></p>
                        <span>Program: </span>
                        <br>
                        <code>
                            import numpy as np
                            <br>from datetime import datetime
                            <br>begin = datetime.now()
                            <br>a = np.zeros((10000, 300, 400))
                            <br>after = datetime.now()
                            <br>print("Time taken by zeros: ", after-begin)
                            <br>a = None
                            <br>begin = datetime.now()
                            <br>a = np.empty((10000, 300, 400))
                            <br>after = datetime.now()
                            <br>print("Time taken by empty: ", after-begin)
                        </code>
                    </ul>

                    <h3>Array Creation by using random module</h3>
                    <ul>
                        <li>randint()</li>
                        <li>rand()</li>
                        <li>uniform()</li>
                        <li>randn()</li>
                        <li>normal()</li>
                        <li>shuffle()</li>
                    </ul>

                    <p>
                        <b>randint(): </b>
                    <ul>
                        <li>To generate a random integer value in the given range.</li>
                        <span>Example: </span>
                        <code>
                                >>> import numpy as np
                                <br>>>> help(np.randint) (#Error)
                                <br>>>> help(np.random.randint)
                            </code><br>
                        <span>Syntax: </span>
                        <code>randint(low, high=None, size=None, dtype=int)</code>
                        <li> Return random integers from `low` (inclusive) to `high` (exclusive).
                            <br><code>[low, high)</code>
                        </li>
                        <span>Example: </span>
                        <code>>>> np.random.randint(10, 20)</code>
                        <li>To create <b>1-D array</b> of size 10 with random values from 1 to 9.</li>
                        <code>>>> np.random.randint(1, 10, size = 10)
                                #array([9, 3, 6, 7, 5, 5, 8, 7, 4, 8], dtype=int32)</code>
                        <li><b>2-D Array</b> from 0 to 99 random values</li>
                        <code>>>> np.random.randint(100, size = (3, 4))</code>
                        <li><b>3-D Array</b></li>
                        <code>>>> np.random.randint(100, size = (2, 3, 4))</code>

                        <p><b>How to convert from one array type to another type</b></p>
                        <ul>
                            <li>We have to use astype() method.</li>
                            <span>Example: </span>
                            <code>>>> a = np.random.randint(1, 10, size = 10)
                        <br>>>> a.dtype
                        #dtype('int32')
                        <br>>>> b = a.astype('float')
                        <br>>>> b.dtype
                        #dtype('float64')</code>
                        </ul>
                    </ul>
                    </p>

                    <p>
                        <b>rand(): </b>
                    <ul>
                        <li><b>Uniform distribution: </b>-- 10 11 9 10 11 10</li>
                        <li><b>Normal distribution: </b>-- 6 4 10 4 14 (10 is mean value)</li>
                        <li>It will generate random float values in the range(0, 1) from uniform distribution samples.
                        </li>
                        <span>Example: </span>
                        <code>>>> np.random.rand() #A single float value will be generated.</code>
                        <li><b>1-D Array: </b></li>
                        <span>Example: </span>
                        <code>>>> np.random.rand(10)</code>
                        <li><b>2-D Array: </b></li>
                        <span>Example: </span>
                        <code>>>> np.random.rand(2, 3)</code>
                        <li><b>3-D Array: </b></li>
                        <span>Example:
                            <code>>>> np.random.rand(2, 3, 4)</code>
                        </span>
                    </ul>
                    </p>

                    <p>
                        <b>uniform():</b>
                    <ul>
                        <li><b>rand(): </b>Range is always [0, 1]</li>
                        <li><b>uniform(): </b>Customized range.</li>
                        <span>Syntax: </span>
                        <code>uniform(low=0.0, high=1.0, size=None)</code>

                        <span>Example: </span>
                        <code>
                                >>> np.random.uniform()
                                <br>>>> np.random.uniform(10, 20)
                            </code>
                        <li><b>1-D Array: </b></li>
                        <code>>>> np.random.uniform(10, 20, size = 5)</code>
                        <li><b>2-D Array: </b></li>
                        <code>>>> np.random.uniform(10, 20, size = (3, 4))</code>
                        <li><b>3-D Array: </b></li>
                        <code>>>> np.random.uniform(10, 20, size = (2, 3, 4))</code>
                    </ul>
                    </p>

                    <p>
                        <b>randn():</b>
                    <ul>
                        <li>Values from normal distribution with mean 0 and variance is 1.</li>
                        <li><b>1-D Array: </b></li>
                        <code>>>> np.random.randn(10)</code>
                        <li><b>2-D Array: </b></li>
                        <code>>>> np.random.randn(2, 3)</code>
                        <li><b>3-D Array: </b></li>
                        <code>>>> np.random.randn(2, 3, 4)</code>

                    </ul>
                    </p>

                    <p>
                        <b>normal():</b>
                    <ul>
                        <li>We can customize mean and variance.</li>
                        <span>Syntax: </span>
                        <code>normal(loc=0.0, scale=1.0, size=None)</code>
                        <li><b>1-D Array: </b></li>
                        <code>>>> np.random.normal(10, 4, size = 10)</code>
                        <li><b>2-D Array:</b></li>
                        <code>>>> np.random.normal(10, 4, size = (2, 3))</code>
                        <li><b>3-D Array:</b></li>
                        <code>>>> np.random.normal(10, 4, size = (2, 3, 4))</code>
                    </ul>
                    </p>

                    <p>
                        <b>shuffle():</b>
                    <ul>
                        <li>Modify a sequence in-place by shuffling its contents.</li>
                        <li><b>1-D Array:</b></li>
                        <code>>>> a = np.arange(9)
                            <br>>>> a
                            #array([0, 1, 2, 3, 4, 5, 6, 7, 8])
                            <br>>>> np.random.shuffle(a) (inline shuffling happens)
                            <br>>>> a
                            #array([4, 2, 6, 1, 5, 8, 3, 7, 0])</code>
                        <li><b>2-D Array: </b>Internal content never changed only the rows shuffled.</li>
                        <code>>>> a = np.random.randint(1, 101, size = (6, 5))
                            <br>>>> a
                            <br>>>> np.random.shuffle(a)
                            <br>>>> a
                        </code>
                        <li><b>3-D Array:</b> If we shuffle for 3-D array, then the order of 2-D arrays will be changed
                            but not it's internal content.</li>
                        <code>>>> a = np.arange(48).reshape(4, 3, 4)
                            <br>>>> a
                            <br>>>> np.random.shuffle(a)
                            <br>>>> a
                        </code>

                    </ul>
                    </p>

                    <h3>Summary of random library functions</h3>
                    <ul>
                        <li><b>randint(): </b>To generate random int values in the given range.</li>
                        <li><b>rand(): </b>To generate uniform distribution float values in the range of [0, 1)</li>
                        <li><b>uniform(): </b>To generate uniform distributed float values in the given range. [low,
                            high]</li>
                        <li><b>randn(): </b>Normal distributed float values with mean value 0 and standard deviation 1.
                        </li>
                        <li><b>normal(): </b>Normal distributed float values with specified mean and standard deviation.
                        </li>
                        <li><b>shuffle(): </b>To shuffle order of elements in the given array.</li>
                    </ul>
                </div>

                <div class="attribute">
                    <h3>Array Attributes</h3>
                    <ul>
                        <li><b>ndim: </b>-- Returns the dimension of the array.</li>
                        <li><b>shape: </b>-- Returns the shape of the array (10,) 1-D, (10, 3) 2-D</li>
                        <li><b>size: </b>-- To get total number of elements.</li>
                        <li><b>dtype: </b>-- To get data type of elements of the array.</li>
                        <li><b>itemsize: </b>-- Lenght of each element of array in bytes (4 - bytes)</li>
                        <span>Example: </span>
                        <code>>>> a = np.array([10, 20, 30, 40])
                            <br>>>> a.ndim
                            #1
                            <br>>>> a.shape
                            #(4,)
                            <br>>>> a.size
                            #4
                            <br>>>> a.dtype
                            #dtype('int64')
                            <br>>>> a.itemsize
                            #8</code>
                    </ul>
                </div>

                <div class="dataType">
                    <h3>NumPy Data Types</h3>
                    <ul>
                        <li><b>Python Data Types: </b>int, float, str, complex, bool, etc...</li>
                        <li><b>NumPy Data Types: </b>Multiple data types present (Python + C).</li>
                        <ul>
                            <li><b>i -- </b>integer (int8, int16, int 32, int64)</li>
                            <li><b>b -- </b>boolean</li>
                            <li><b>u -- </b>unsigned integer (uint8, uint16, uint32, uint64)</li>
                            <li><b>f -- </b>float (float16, float32, float64)</li>
                            <li><b>c -- </b>complex (complex64, complex128)</li>
                            <li><b>s -- </b>string</li>
                            <li><b>U -- </b>Unicode String</li>
                            <li><b>M -- </b>datetime etc...</li>
                            <li><b>int8 -- </b>i1, <b>int16 -- </b>i2, <b>int32 -- </b>i4(default)</li>
                            <li><b>float16 -- </b>f2, <b>float32 -- </b>f4(default), <b>float64 -- </b>f8</li>
                        </ul>
                        <li><b>int8: </b></li>
                        <ul>
                            <li>The value will be represnted by 8bits.</li>
                            <li>MSB (Most Significant Bits) is reserved for sign.</li>
                            <li>The range: -128 to 127</li>
                        </ul>
                    </ul>

                    <h3>Changing the data type of an existing array</h3>
                    <ul>
                        <li><b>"astype()"</b></li>
                        <span>Ex: </span>
                        <code>>>> import numpy as np
                            <br>>>> a = np.array([10, 20, 30])
                            <br>>>> b = a.astype('float64')
                            <br>>>> print(a.dtype)
                            #int64
                            <br>>>> b.dtype
                            #dtype('float64')</code>
                        <li>By using built-in function of NumPy like <b>"float64"</b></li>
                        <span>Ex: </span>
                        <code>>>> a = np.array([10, 20, 30])
                            <br>>>> b = np.float64(a)
                            <br>>>> a.dtype
                            #dtype('int64')
                            <br>>>> b.dtype
                            #dtype('float64')</code>
                        <li><b>Boolean: </b></li>
                        <span>Ex: </span>
                        <code>>>> a = np.array([0, 20, 0])
                                <br>>>> b = np.bool(a) #Invalid
                                <br>>>> b = np.bool_(a)
                                <br>>>> b
                                #array([False,  True, False])</code>
                    </ul>

                    <h3>How to get/access elements of NumPy Array</h3>
                    <ul>
                        <li>Indexing</li>
                        <li>Slicing</li>
                        <li>Advanced Indexing</li>
                    </ul>

                    <p><b>Indexing:</b></p>
                    <ul>
                        <li>By using index, we can get single element of the array.</li>
                        <li>Zero based indexing. i.e the index of the first element is 0.</li>
                        <li>Supports both +ve and -ve indexing.</li>
                    </ul>

                    <p><b>From 1-D Array: </b></p>
                    <ul>
                        <li>a[index]</li>
                        <span>Ex: </span>
                        <code>>>> a = np.array([10, 20, 30, 40])
                            <br>>>> a
                            #array([10, 20, 30, 40])
                            <br>>>> a[-1] #40</code>
                    </ul>

                    <p><b>From 2-D Array:</b></p>
                    <ul>
                        <li>a[rowIndex][columnIndex]</li>
                        <span>Ex: </span>
                        <code>>>> a = np.array([[10, 20, 30], [40, 50, 60]])
                            <br>>>> a
                            #array([[10, 20, 30],
                                   [40, 50, 60]])</code>
                        <li>To access 50</li>
                        <code>>>> a[1][1] #50
                            <br>>>> a[1][-2]
                            <br>>>> a[-1][-2]
                            <br>>>> a[-1][1]
                        </code>
                    </ul>

                    <p><b>From 3-D Array:</b></p>
                    <ul>
                        <li>a[i][j][k]</li>
                        <li>i -- Represents which 2-D Array(index of 2-D Array), <br>j -- Represents row index in that
                            2-D array
                            <br>k -- Represents column index of that 2-D array
                        </li>
                        <li><b>a[0][1][2]: </b>
                            <ul>
                                <li>0-indexed 2-D array.</li>
                                <li>In that 2-D array indexed row and 2 indexed column.</li>
                            </ul>
                        </li>
                        <span>Ex: </span>
                        <code>>>> l = [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 11, 12], [13, 14, 15], [16, 17, 18]]]
                            <br>>>> l
                            #[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[10, 11, 12], [13, 14, 15], [16, 17, 18]]]
                            <br>>>> a = np.array(l)
                            <br>>>> a
                            #array([[[ 1,  2,  3],
                                    [ 4,  5,  6],
                                    [ 7,  8,  9]],
                            
                                   [[10, 11, 12],
                                    [13, 14, 15],
                                    [16, 17, 18]]])</code>
                        <li>To access 14</li>
                        <code>>>> a[1][1][1]
                            <br>>>> a[-1][-2][-2]
                            <br>>>> a[1][-2][-2]
                            <br>>>> a[-1][1][-2]</code>
                    </ul>

                    <h3>Accessing elements of ndarray by using slice operator</h3>
                    <ul>
                        <li><b>1-D Array: </b>a[begin:end:step]</li>
                        <code>>>> a = np.arange(10, 101, 10)
                            <br>>>> a
                            #array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
                            <br>>>> a[2:5]
                            #array([30, 40, 50])
                            <br>>>> a[::1]
                            #array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
                            <br>>>> a[::-1]
                            #array([100,  90,  80,  70,  60,  50,  40,  30,  20,  10])
                            <br>>>> a[::-2]
                            #array([100,  80,  60,  40,  20])</code>
                        <li><b>2-D Array: </b>a[row, column], a[begin:end:step, begin:end:step]</li>
                        <code>
                            >>> a = np.array([[10, 20], [30, 40], [50, 60]])
                            <br>>>> a
                            #array([[10, 20],
                                    [30, 40],
                                    [50, 60]])
                        </code>
                        <li>Access [10, 20]</li>
                        <code>
                            >>> a[0:1]
                            #array([[10, 20]])
                            <br>>>> a[0:1, :]
                            #array([[10, 20]])
                            <br>>>> a[0, :]
                            #array([10, 20]) #It is 1-D array
                            <br>>>> a[0::2, :]
                            #array([[10, 20],
                                   [50, 60]])
                            <br>>>> a[0: 2, 1:2]
                            #array([[20],
                                  [40]])
                            <br>>>> a[:2, 1:]
                        </code>
                        <br><span>Ex: </span><br>
                        <code>
                            >>> a = np.array([[1, 2, 3, 4], [5, 6, 7,8], [9, 10, 11, 12], [13, 14, 15, 16]])
                            <br>>>> a
                            #array([[ 1,  2,  3,  4],
                                [ 5,  6,  7,  8],
                                [ 9, 10, 11, 12],
                                [13, 14, 15, 16]])
                            <br>>>> a[:2, :]
                            #array([[1, 2, 3, 4],
                                [5, 6, 7, 8]])
                            <br>>>> a[0::3, :]
                            #array([[ 1,  2,  3,  4],
                                [13, 14, 15, 16]])
                            <br>>>> a[:, :2]
                            #array([[ 1,  2],
                                   [ 5,  6],
                                   [ 9, 10],
                                   [13, 14]])
                            <br>>>> a[:, :: 2]
                            #array([[ 1,  3],
                                   [ 5,  7],
                                   [ 9, 11],
                                   [13, 15]])
                            <br>>>> a[1:3, 1:3]
                            #array([[ 6,  7],
                                   [10, 11]])
                            <br>>>> a[0::3, 0::3]
                            #array([[ 1,  4],
                                   [13, 16]])
                        </code>

                        <p><b>Slice in 3-D Array</b></p>
                        <p>
                            (2, 3, 4) -- (i, j, k)
                            <br>2 -- Number of 2-D Arrays
                            <br>3 -- The number of rows
                            <br>4 -- Number of columns
                        </p>
                        <span>Syntax: </span><br>
                        <code>>>> a[i, j, k]
                            <br>>>> a[begin:end:step, begin:end:step, begin:end:step]
                        </code>
                        <br><span>Ex: </span>
                        <br><code>
                            >>> import numpy as np
                            <br>>>> l = [[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], [[13, 14, 115, 16], [17, 18, 19, 20], [21, 22, 23, 24]]]
                            <br>>>> a = np.array(l)
                            <br>>>> a
                            <br>>>> a[:, :, :1]
                            #array([[[ 1],
                                    [ 5],
                                    [ 9]],
                            
                                   [[13],
                                    [17],
                                    [21]]])
                            <br>>>> a[:, :1, :]
                            #array([[[  1,   2,   3,   4]],
                                    
                                   [[ 13,  14, 115,  16]]])
                            <br>>>> a[:, ::2, :]
                            #array([[[  1,   2,   3,   4],
                                    [  9,  10,  11,  12]],
                                    
                                    [[ 13,  14, 115,  16],
                                    [ 21,  22,  23,  24]]])
                            <br>>>> a[:, :2, 1:3]
                            #array([[[  2,   3],
                                    [  6,   7]],
                            
                                   [[ 14, 115],
                                    [ 18,  19]]])
                            <br>>>> a[:, ::3, ::3]
                            #array([[[ 1,  4],
                                    [ 9, 12]],
                    
                                    [[13, 16],
                                    [21, 24]]])
                        </code>

                        <li>To use slice operator, compulsory elements should be in order. We cann't select elements
                            which are out of order. i.e we cann't select arbitrary elements.</li>
                    </ul>

                    <h3>Advanced Indexing</h3>
                    <ul>
                        <li>By usnig index, we can access only one element at a time.</li>
                        <code>1-D -- a[i]
                            <br>2-D -- a[i][j]
                            <br>3-D -- a[i][j][k]
                        </code>
                        <li>By using slice operator we can access multiple elements at a time, but all elements should
                            be in order/sequence.</li>
                        <code>
                            1-D -- a[begin:end:step]
                            <br>2-D -- a[begin:end:step, begin:end:step]
                            <br>3-D -- a[begin:end:step, begin:end:step, begin:end:step]
                        </code>
                        <p><b>Accessing Multiple arbitrary elements</b></p>
                        <ul>
                            <li><b>1-D Array: </b></li>
                            <ul>
                                <li><b>array[x]: </b>"x" can be either nd array or list, which represents required
                                    indexes.</li>
                            </ul>
                            <li><b>1st Way:</b></li>
                            <span>Required values are "30, 50, 60, 90": </span>
                            <br><code>>>> a = np.arange(10, 101, 10)
                                <br>>>> a
                                #array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])</code>
                            <li>Create ndarray with required indices.</li>
                            <code>
                                >>> indices = np.array([2, 4, 5, 8])
                                <br>>>> indices
                                #array([2, 4, 5, 8])
                                </code>
                            <li>Pass this indices array as argument to orignal array</li>
                            <code>
                                >>> a[indices]
                                #array([30, 50, 60, 90])</code>
                            <li><b>2nd Way:</b></li>
                            <code>>>> l = [2, 4, 5, 8]
                                    <br>>>> a[l]
                                    #array([30, 50, 60, 90])</code><br>
                            <span>Required value: [10, 50, 70, 100]</span><br>
                            <code>>>> l = [0, 4, 6, 9]
                                <br>>>> a[l]
                                #array([ 10,  50,  70, 100])
                                <br>>>> indices = np.array([0, 4, 6, 9])
                                <br>>>> a[indices]</code>
                            <br><span>Values: [10, 100, 50, 70]</span>
                            <br><code>>>> l = [0, 9, 4, 6]
                                <br>>>> a[l]
                                #array([ 10, 100,  50,  70])
                                <br>>>> a[[0, 9, 4, 6]]</code>
                            <br><span>value: [10, 100]</span>
                            <br><code>>>> a[[0, 9]]
                                #array([ 10, 100])
                                <br>>>> a[[0, -1]]</code>
                        </ul>

                        <p><b>Access elements of 2-D Array:</b></p>
                        <ul>
                            <code>>>> l = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
                                <br>>>> l
                                #[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
                                <br>>>> a = np.array(l)
                                <br>>>> a
                                #array([[ 1,  2,  3,  4],
                                       [ 5,  6,  7,  8],
                                       [ 9, 10, 11, 12],
                                       [13, 14, 15, 16]])</code>
                            <br>
                            <span>Syntax: </span>
                            <br><code>a[[row_indices], [column_indices]]</code>
                            <br><span>Ex: Value: [1, 6, 11, 16]</span>
                            <br><code>>>> a[[0, 1, 2,3], [0, 1, 2, 3]]
                                #array([ 1,  6, 11, 16])
                            <br>It select elements from: (0, 0), (1, 1), (2, 2), (3, 3)</code>
                            <br><span>Ex: Value: [2, 8, 9, 15]</span>
                            <br><code>>>> a[[0, 1, 2, 3], [1, 3, 0, 2]]
                                #array([ 2,  8,  9, 15])</code>
                            <br><span>L-Shape Elements: </span>
                            <br><code>>>> a[[0, 1, 2, 3, 3, 3, 3], [0, 0, 0, 0, 1, 2, 3]]
                                #array([ 1,  5,  9, 13, 14, 15, 16])</code>
                        </ul>

                        <p><b>Accessing multiple arbitrary elements in 3-D array:</b></p>
                        <ul>
                            <span>Ex: </span>
                            <br><code>>>> a = np.arange(1, 25).reshape(2, 3, 4)
                                <br>>>> a
                                array([[[ 1,  2,  3,  4],
                                        [ 5,  6,  7,  8],
                                        [ 9, 10, 11, 12]],
                                
                                       [[13, 14, 15, 16],
                                        [17, 18, 19, 20],
                                        [21, 22, 23, 24]]])</code>
                            <br><span>Syntax:</span>
                            <br><code>a[[indices of 2-D array], [row indices], [column indices]]</code>
                            <br><span>Accessing 7 and 18 from the array</span>
                            <br><code>>>> a[[0, 1], [1, 1], [2, 1]]
                                #array([ 7, 18])</code>
                        </ul>

                        <p><b>Condition based selection:</b></p>
                        <ul>
                            <li>We can select elements based on some condition also.</li>
                            <span>Syntax:</span>
                            <br><code>array[boolean_array]</code>
                            <li>In the boolean array, where ever True present the corresponding value will be selected.
                            </li>
                            <span>Ex: </span>
                            <br><code>>>> a = np.array([10, 20, 30, 40])
                                <br>>>> boolean_array = np.array([True, False, False, True])
                                <br>>>> boolean_array
                                #array([ True, False, False,  True])
                                <br>>>> a[boolean_array]
                                #array([10, 40])
                               </code>
                            <li>Select elements which are greater than 25</li>
                            <code>>>> b_a = a > 25 (#first Way)
                                <br>>>> a[b_a] 
                                #array([30, 40])
                                <br>>>> a[a > 25] (#2nd way)
                                #array([30, 40])</code>
                            <br><span>Ex: </span>
                            <br><code>>>> a = np.array([10, -5, 20, 40, -3, -1, 75])
                                <br>>>> a
                                #array([10, -5, 20, 40, -3, -1, 75])
                                <br>>>> a[a &lt; 0]
                                #array([-5, -3, -1])
                                <br>>>> a[a &gt; 0]
                                #array([10, 20, 40, 75])
                                <br>>>> a[a % 2 == 0]
                                #array([10, 20, 40])</code>
                        </ul>

                        <p><b>Condition Based selection 2-D Array also</b></p>
                        <ul>
                            <code>>>> a = np.arange(1, 26).reshape(5, 5)
                                <br>>>> a
                                #array([[ 1,  2,  3,  4,  5],
                                       [ 6,  7,  8,  9, 10],
                                       [11, 12, 13, 14, 15],
                                       [16, 17, 18, 19, 20],
                                       [21, 22, 23, 24, 25]])
                                <br>>>> a[a % 2 == 0]
                                #array([ 2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24])
                                <br>>>> a[a % 10 == 0]
                                #array([10, 20])</code>
                        </ul>
                    </ul>

                    <h3>Slicing vs Advanced Indexing</h3>
                    <ul>
                        <p><b>Python's Slicing:</b></p>
                        <li>In case of list, slice operator will creates a separate copy.</li>
                        <li>if we perform any changes in one copy those changes won't be reflected in other copy.</li>
                        <span>Ex: </span>
                        <br><code>l1 = [10, 20, 30, 40]
                            <br>l2 = l1[:]
                            <br>l2[1] = 333
                            <br>l[1] = 999
                            <br>print(l1)
                            <br>print(l2)
                        </code>

                        <p><b>NumPy Array Slicing:</b></p>
                        <li>A separate copy won't be created and just we are getting view of the original copy.</li>
                        <code>>>> a = np.arange(10, 101, 10)
                            <br>>>> a
                            <br>>>> b = a[0:4]
                            <br>>>> b
                            <br>>>> a[0] = 333
                            <br>>>> a
                            <br>>>> b
                            <br>b[1] = 999
                            <br>b
                            <br>a
                        </code>
                    </ul>

                    <h3>Advanced Indexing and Condition Based Selection</h3>
                    <ul>
                        <li>It will select required element based on provided index or condition and with those elements
                            a new 1-D array object will be created.</li>
                        <li>The output is always a new 1-D array only.</li>
                        <span>Ex: </span>
                        <code>>>> a = np.arange(10, 101, 10)
                            <br>>>> a
                            #array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
                            <br>>>> b = a[[0, 2, 5]]
                            <br>>>> b
                            #array([10, 30, 60])
                            <br>>>> a[0] = 333
                            <br>>>> a
                            #array([333,  20,  30,  40,  50,  60,  70,  80,  90, 100])
                            <br>>>> b
                            #array([10, 30, 60])
                            <br>>>> b[0] = 999
                            <br>>>> b
                            #array([999,  30,  60])
                            <br>>>> a
                            #array([333,  20,  30,  40,  50,  60,  70,  80,  90, 100])
                        </code>
                    </ul>

                    <h3>Slicing Vs Advanced Indexing</h3>
                    <b>Slicing:</b>
                    <ul>
                        <li>The elements should be ordered.</li>
                        <li>We can't select arbitrary elements.</li>
                        <li>Conditional based selection is not possible.</li>
                        <li>Just we will get view but not copy.</li>
                        <li>Memory, performance-wise it is the best.</li>
                    </ul>

                    <b>Advanced Indexing:</b>
                    <ul>
                        <li>The elements need not be ordered.</li>
                        <li>We can select arbitrary elements.</li>
                        <li>Condition based selection is possible.</li>
                        <li>Just we will get separate copy but not view.</li>
                        <li>Memory, performance-wise not up to mark.</li>
                    </ul>

                    <h3>Summary of Syntaxes</h3>
                    <b>Basic Indexing:</b>
                    <ul>
                        <li><b>1-D Array: </b>
                            <code>a[i]</code>
                        </li>
                        <li><b>2-D Array: </b>
                            <code>a[i][j] or a[i, j]</code>
                        </li>
                        <li><b>3-D Array: </b>
                            <code>a[i][j][k] or a[i, j, k]</code>
                        </li>
                    </ul>

                    <b>Slicing:</b>
                    <ul>
                        <li><b>1-D Array: </b>
                            <code>a[begin: end: step]</code>
                        </li>
                        <li><b>2-D Array: </b>
                            <code>a[begin: end: step, begin: end: step]</code>
                        </li>
                        <li><b>3-D Array: </b>
                            <code>a[begin: end: step, begin: end: step, begin: end: step]</code>
                        </li>
                    </ul>

                    <b>Advanced Indexing:</b>
                    <ul>
                        <li><b>1-d Array: </b>
                            <code>a[x]</code> -- x contains ndarray or list
                        </li>
                        <li><b>2-D Array: </b>
                            <code>a[[row_indices], [column_indices]]</code>
                        </li>
                        <li><b>3-D Array: </b>
                            <code>a[[indices of 2-D Array], [row_indices], [column_indices]]</code>
                        </li>
                    </ul>

                    <b>Condition Based Selection:</b>
                    <ul>
                        <li><code>a[condition] -- a[a > 0]</code></li>
                        <li>This is same for all 1-D, 2-D and 3-D Arrays.</li>
                    </ul>
                </div>

                <div class="iteration">
                    <h3>How to Iterate Elements of the ndarray</h3>
                    <p>Iteration means getting all elements one-by-one.</p>
                    <b>3-Ways:</b>
                    <ul>
                        <li>By using Python's loop.</li>
                        <li>By using nditer() function.</li>
                        <li>By using ndenumerate() function.</li>
                    </ul>
                    <b>By using Python's Loop:</b>
                    <ul>
                        <li>To iterate Elements of 1-D Array</li>
                        <span>Ex: </span>
                        <code>import numpy as np
                            <br>a = np.arange(10, 51, 10)
                            <br>for x in a:
                            <ul><code>print(x)</code>
                    </ul>
                    </code>

                    <li>To iterate Elements of 2-D Array</li>
                    <span>Ex: </span>
                    <code>a = np.array([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
                            <br># print(a)
                            <br>for x in a: # x is 1-D array but not scalar value
                                <ul><code># print(x)
                                <br>for y in x: # y is a scalar value present in 1-D array</code>
                    <ul><code>print(y)</code></ul>
                    </ul>
                    </code>

                    <li>To iterate Elements of 3-D Array</li>
                    <span>Ex: </span>
                    <code>a = np.array([[[10, 20], [30, 40]], [[50, 60], [70, 80]]])
                            <br># print(a)
                            <br>for x in a: # x is 2-D Array but not scalar value
                            <ul><code># print(x)
                                <br>for y in x: # y is 1-D Array but not scalar value
                            </code>
                    <ul><code># print(y)
                                <br>for z in y: # z is a scalar value
                            </code>
                        <ul><code>print(z)</code></ul>
                    </ul>
                    </ul>

                    </code>
                    <p><span>Note: </span>
                        <code>To iterate elements of n-D Array, we required n-;oops.</code>
                    </p>
                    </ul>
                    <b>By using Numpy's nditer():</b>
                    <ul>
                        <li>Advantages for any n-D Array only onne loop is enough.</li>
                        <li>nditer is a class present in numpy module.</li>
                        <li><b>nditer() -- </b>Creating an object of nditer class.</li>

                        <br><b>1-D Array:</b>
                        <br><span>Ex: </span>
                        <code>a = np.arange(10, 51, 10)
                            <br>for x in np.nditer(a):
                            <ul><code>print(x)</code>
                    </ul>
                    </code>
                    <br>
                    <b>2-D Array:</b>
                    <br><span>Ex: </span>
                    <code>a = np.array([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
                        <br>for x in np.nditer(a):
                        <ul><code>print(x)</code></ul>
                    </code>
                    <br>
                    <b>3-D Array:</b>
                    <br><span>Ex: </span>
                    <code>a = np.array([[[10, 20], [30, 40]], [[50, 60], [70, 80]]])
                        <br>for x in np.nditer(a):
                        <ul><code>print(x)</code></ul>
                    </code>
                    <br>
                    <b>Iterate elements of Sliced Array:</b>
                    <br><span>Ex: </span>
                    <code>a = np.array([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
                        <br># print(a[:,:2])
                        <br>for x in np.nditer(a[:, : 2]):
                        <ul><code>print(x)</code></ul>
                    </code>
                    <br>
                    <b>Using nditer() to get elements of required datatype:</b>
                    <br><span>Ex: </span>
                    <code>for x in np.nditer(a, flags=['buffered'], op_dtypes=['float']):
                        <br>"op_dtypes" is used to change type
                    </code></ul>

                    <h3>Normal Python Loops vs nditer():</h3>
                    <ul>
                        <b>Python:</b>
                        <ul>
                            <li>n-loops are required.</li>
                            <li>There is no way to specify our required dtype.</li>
                        </ul>

                        <b>nditer():</b>
                        <ul>
                            <li>Only one loop is enough.</li>
                            <li>There is a way to specify required dtype. For this we have to use "op_dtype" argument.
                            </li>
                        </ul>
                    </ul>

                    <b>By using ndenumerate() function:</b>
                    <ul>
                        <li>If we want to find co-ordinates also in addition to element.</li>
                        <li>Array indices(co-ordinates) and values.</li>
                        <p><b>1-D Array:</b></p>
                        <span>Ex: </span>
                        <code>
                            a = np.array([10, 20, 30, 40, 50])
                            <br>for pos, element in np.ndenumerate(a):
                            <br>
                            <ul>
                                <code>print(f'{element} element present at index/position: {pos}')</code>
                    </ul>
                    </code>

                    <p><b>2-D Array:</b></p>
                    <span>Ex: </span>
                    <code>
                            a = np.array([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
                            <br>for pos, element in np.ndenumerate(a):
                            <br>
                            <ul>
                                <code>print(f'{element} element present at index/position: {pos}')</code>
                    </ul>
                    </code>

                    <p><b>3-D Array:</b></p>
                    <span>Ex: </span>
                    <code>
                            a = np.arange(1, 25).reshape(2, 3,4)
                            <br>for pos, element in np.ndenumerate(a):
                            <ul>
                                <code>print(f'{element} element present at index/position: {pos}')</code>
                    </ul>
                    </code>
                    </ul>
                </div>

                <div class="operators">
                    <h3>Arithmatic Operators <span>(+, -, *, /, **, //)</span></h3>
                    <b>1-D Array:</b>
                    <ul>
                        <span>Ex: </span>
                        <code>
                            >>> a = np.array([10, 20, 30, 40])
                            <br>>>> print(a + 2)
                            <br>>>> print(a - 2)
                            <br>>>> print(a * 2)
                            <br>>>> print(a / 2)
                            <br>>>> print(a % 2)
                            <br>>>> print(a // 2)
                        </code>
                    </ul>

                    <b>2-D Array: </b>
                    <ul> <span>Ex: </span>
                        <code>
                            >>> a = np.array([[10, 20, 30], [40, 50, 60]])
                            <br>>>> print(a + 2)
                            <br>>>> print(a - 2)
                            <br>>>> print(a * 2)
                            <br>>>> print(a / 2)
                            <br>>>> print(a % 2)
                            <br>>>> print(a // 2)
                        </code>

                        <li>In python anything by <code>"zero"</code> including <code>"zero/zero"</code> result is
                            always <code>"ZeroDivisionError"</code>.</li>
                        <li>But in NumPy there is no <code>"ZeroDivisionError"</code></li>
                        <span>Ex: </span>
                        <code>
                            10/0 -- infinity(inf)
                            <br>0/0 -- undefined(NaN -- Not a Number)
                        </code>
                    </ul>

                    <h3>Arithmatic Operators for Arrays with Arrays</h3>
                    <ul>
                        <li>Compulsory both arrays should have</li>
                        <ul>
                            <li>Same dimention</li>
                            <li>Same shape and</li>
                            <li>Same size</li>
                        </ul>
                        <li>Otherwise we will get error.</li>
                    </ul>

                    <b>1-D Array:</b><br>
                    <ul>
                        <span>Ex: </span>
                        <code>
                            >>> a = np.array([10, 20, 30, 40])
                            <br>>>> b = np.array([1, 2, 3, 4])
                            <br>>>> a.ndim
                            # 1
                            <br>>>> b.ndim
                            # 1
                            <br>>>> a.shape
                            # (4,)
                            <br>>>> b.shape
                            # (4,)
                            <br>>>> a.size
                            # 4
                            <br>>>> b.size
                            # 4
                            <br>>>> b + a
                            # array([11, 22, 33, 44])
                            <br>>>> b - a
                            # array([ -9, -18, -27, -36])
                            <br>>>> a + b
                            # array([11, 22, 33, 44])
                            <br>>>> a - b
                            # array([ 9, 18, 27, 36])
                            <br>>>> a * b
                            # array([ 10,  40,  90, 160])
                            <br>>>> a / b
                            # array([10., 10., 10., 10.])
                            <br>>>> a // b
                            # array([10, 10, 10, 10])
                        </code>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <a href="#top">
        <div class="backToTop">↑</div>
    </a>
</body>

</html>